{"_id":"SybLfJcYb","title":"Lesson 2: General Notes","body":{"entityMap":{},"blocks":[{"key":"bg8ne","text":"Lesson 2: General Notes","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cnn10","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2gisj","text":"Parentheses for methods are optional in ruby","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cfc0m","text":"Simple gotcha listed below","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"flq0q","text":"if operator == '1' # ok for comparison","type":"custom-code-block-ruby","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9e0r2","text":"...","type":"custom-code-block-ruby","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5k3me","text":"if operator = '1' # will always return true","type":"custom-code-block-ruby","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"28id0","text":"In ruby, if expressions can return a value","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":9,"length":2,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"125f2","text":"Local variables within an if can be accessed outside of the if (if condition does not create a block)","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":26,"length":2,"style":"CODE"},{"offset":60,"length":2,"style":"CODE"},{"offset":65,"length":1,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"4tvli","text":"There are 2 layers to solving a program","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dnu9a","text":"The logical program domain layer","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f0vo4","text":"The syntatical programming language layer","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ac0fo","text":"Formal Pseudo-Code","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":18,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1oe8k","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ea434","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3drut","text":"keywordmeaningSTARTstart of the programSETsets a variable we can use for laterGETretrieve input from userPRINTdisplays output to userREADretrieve value from variableIF / ELSE IF / ELSEshow conditional branches in logicWHILEshow looping logicENDend of the program","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5ic4d","text":"---","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"afr74","text":"Flow Diagrams","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":13,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6h99g","text":"=================","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dgvut","text":"Mapping out problems in a step-by-step logic for our iteration logic for our program is called imperative or prodedural way. Using each ( a method that has been encapsulated into a method) is a declarative way of solving a problem. ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":95,"length":11,"style":"ITALIC"},{"offset":109,"length":11,"style":"ITALIC"},{"offset":194,"length":12,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"bo79e","text":"When moving logic to sub-processes, we are able to use a declarative type of syntax rather than imperative. ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":57,"length":11,"style":"ITALIC"},{"offset":96,"length":10,"style":"ITALIC"},{"offset":68,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"cjvqd","text":"When making flow diagrams, start at a high level, using declarative syntax.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":56,"length":11,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"cuh0h","text":"---","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e8vj1","text":"Debugging","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"2uq5h","text":"=============","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fcejv","text":"Temperament","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":11,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"8milo","text":"Key to debugging is having a good and logical temperament","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4o85p","text":"Be even-keeled and systematic","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"edb7t","text":"Dealing with feelings of frustration is the fist critical aspect of learning to program","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5vo8h","text":"Reading Error Messages","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":22,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"aio4s","text":"Stack Trace - the wall of text that looks like gibberish.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5uja2","text":"  * Must learn to carefully read the stack trace","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7agch","text":"  * The error message is the first hint as to where to start looking","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7b1gl","text":"Online Resources","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":16,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"f5ch9","text":"Search Engine","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"638tg","text":"  * Study the error message, and try to walk backwards through the code to understand how the flow of the program arrived at the error condition.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2jnbc","text":"Stack overflow","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"vbqo","text":"Documentation","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"12eo6","text":"Steps to debugging","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":18,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"9uskl","text":"Reproduce the error","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9lsju","text":"Determine the boundaries of the error","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"astot","text":"Modify the code or data to get an idea of the scope of the error and determine the boundaries of the problem","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bbkk3","text":"Trace the code","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"79ia1","text":"The type of assignment where we assign more than one value on the same line is called ‘multiple assignment’","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b742f","text":"Finding the origin of the bug in the code is called trapping the error.","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8kmta","text":"Understand the problem well","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dn2bp","text":"Implement a fix","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"eomf1","text":"Test the fix","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"83agt","text":"Techniques for debugging","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":24,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"91tda","text":"Line by line","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5ievl","text":"Rubber duck debugging","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8gk81","text":"Walking away","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4fqgv","text":"Using pry","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9fp21","text":"a powerful Ruby REPL that can replace IRB","type":"ordered-list-item","depth":1,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"76ejp","text":"Using a debugger","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f6m5k","text":"---","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1vu44","text":"Coding Tips","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"d0ue5","text":"===============","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c2aci","text":"Dramatic Experience and Retaining Knowledge","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":43,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"ff14c","text":"Embrace your burns and remember their lessons","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ijms","text":"Naming Things","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":13,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"cbkcl","text":"Choose descriptive variable and method names","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ejr6m","text":"You don’t want to hardcore possible response values into the variable because of future uncertainty","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b78lq","text":"One small exception to having descriptive names is when you have a very small block of code. It’s less of a problem because the life or scope of that variable doesn’t span more than a couple of lines","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"81svs","text":"Naming Conventions","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":18,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"3034v","text":"When naming things, follow ruby conventions","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"93p55","text":"  * Use snake\\_case when naming everything, except classes which are CamelCase or constants, which are all UPPERCASE.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":8,"length":11,"style":"BOLD"},{"offset":69,"length":10,"style":"BOLD"},{"offset":107,"length":10,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"6kp4","text":"Mutating Constants","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9jjkp","text":"Ruby allows it, but constants should not be mutated at all.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"plm5","text":"Methods","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"33or1","text":"Make sure the method does one thing, and its responsibility is very limited.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2ks02","text":"  * Try to keep methods short, (about 10 lines). More than 15 lines long, it is probably better to split it up into 2 or 3 methods","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"gsda","text":"GENERAL GUIDELINES ON HOW TO WRITE METHODS:","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5aijg","text":"  * Don’t display something to the output and return a meaningful value. Since Ruby always returns a value, the key here is that the return value shouldn't be the intent of the method","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":55,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"15qm1","text":"  * Decide whether the method should return a value with no side effect or perform side effects with no return value. If you do both, you won’t remember what the method does when you need to use it. The method name should reflect whether or not it has side effects or not.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7knpb","text":"  * In Ruby, we would not say ​return_total​, it would just be ​total​ - returning a value is implied. We would not expect the ​total​ method to have side effects or print a value out. It should look like this:","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":30,"length":13,"style":"CODE"},{"offset":63,"length":6,"style":"CODE"},{"offset":127,"length":6,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"12vqq","text":" ​def total(cards) \\#[1,2,3]","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6fnsc","text":" ​end","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6rphu","text":"    * From the name ​total​ you know this method should return an integer. If you find yourself looking at the method implementation, it’s a sign that the method is not named appropriately, or that it’s doing more than one simple thing.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":20,"length":6,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"407th","text":"Methods should be at the same level of abstraction","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c6jm8","text":"When working with a method, you should be able to mentally extrat the method from the larger program, and just work with the method in isolation.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cunj6","text":"  * A method like this, you can use it without thinking about its implementation. Working this way helps compartmentalize your focus, an important skill working on larger codebases.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"80dbm","text":"You shouldn’t care about the implementation when you use a method.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d9cof","text":"Pay attention to how methods are organized, and whether you can look at a list of methods a week later and still understand how to use them without studying their implementation.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6lqil","text":"Method names should reflect mutation","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aqqmi","text":"*​def update_total(total, cards)","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":1,"length":31,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"osb7","text":"*","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ckg34","text":"end","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":3,"style":"ITALIC"},{"offset":0,"length":3,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"b5pen","text":"#total is changed","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":17,"style":"ITALIC"},{"offset":0,"length":17,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"a83e0","text":" ​*When we see the method called ​update_total​, we assume that the paramater passed in to it will be mutated. As such, we wouldn’t expect to use the method like this: ​total = update_total(total, cards)​. In otherwords, we wouldn’t expect the ​update_total​ method to return a value.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":1,"style":"ITALIC"},{"offset":33,"length":13,"style":"CODE"},{"offset":168,"length":35,"style":"CODE"},{"offset":244,"length":13,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"34e3o","text":"  * The less you have to remember, the better.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b6jdo","text":"  * Use naming conventions, even in your own code, to signify which types of methods mutate vs which methods return values.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fv9mg","text":"The more you have to think about a method, the harder it is to use it. If it is performing a side effect and at the same time returning a value, this makes debugging and using the method very hard.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f1ioc","text":"Goal should be to build small methods that are like LEGO blocks: they should be stand-alone pieces of functionality that you can use to piece together larger structures.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"723j4","text":"There are, however, some methods that are convoluted because the logic is complex. It’s likely a sign that you don’t quite understand the problem well enough to break it down into well-compartmentalized pieces.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9rqs3","text":"Displaying Output","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7el87","text":"Sometimes you will have methods that only display things like:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7lpnv","text":"​def welcome","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":12,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"bui2p","text":"  puts “welcome”","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":16,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"esr44","text":"end","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":3,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"bu4d5","text":"​This is fine, but it’s not o​​bvious whether a method called ​welcome​ returns a string, or outputs string directly. One way to resolve this is to help yourself remember and prefix all methods that output values with something like ​print_, say_, or display_​.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":29,"length":1,"style":"CODE"},{"offset":62,"length":8,"style":"CODE"},{"offset":233,"length":7,"style":"CODE"},{"offset":242,"length":4,"style":"CODE"},{"offset":251,"length":8,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"dg3su","text":"This will require some discipline and it’s important that you only output values in these methods. Don’t mutate paramters or return values.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ehen0","text":"Methods are like black-boxes. It takes some stuff (input) and returns some value (output) to you. They should be very contained and you should know what they do without having to look up the implementation. Coding will be much easier if you follow these general guidelines.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5ik7l","text":"Miscellaneous Tips","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e65gr","text":"Don’t prematuretly exit the program. All your methods should be at the same mental scope and not just randomly exit the program. Your program should probably only have one exit point.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"882h4","text":"Clarity over terseness.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"51fjq","text":"Truthiness","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"abdqf","text":"In ruby, everything is true except ​nil​ and ​false​","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4c518","text":"---","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dqgpe","text":"Variable Scope","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"93tpm","text":"==============","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4cv04","text":"In Ruby, there are several different types of variables, each with their own scoping rules. For now, we’ll be talking about local variables","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":124,"length":15,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"dp188","text":"A variable’s scope determines where in a program a variable is available for use.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9ckbn","text":"A variable’s scope is defeined by where the variable is initialized or created.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"do1mk","text":" In Ruby, variable scope is defined by a block which is a piece of code following a method invocation, usually delimited by either curly braces ​{}​ or ​do/end​. Be aware that not all ​do/end​ pairs imply a block.\\","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":214,"style":"ITALIC"},{"offset":144,"length":3,"style":"CODE"},{"offset":152,"length":7,"style":"CODE"},{"offset":184,"length":7,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"ea6fo","text":"Inner scope can access variables initialized in an outer scope, but not vice versa.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dpjbh","text":" \\\\*They key factor for distinguishing for deciding whether a code is considered a block is seeing if the ​{}​ or ​do/end​ immediately follows a method invocation. For example, a ​for​ loop will not createa block because ​for​ is part of the Ruby language and not a method invocation.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":2,"style":"ITALIC"},{"offset":106,"length":3,"style":"CODE"},{"offset":114,"length":7,"style":"CODE"},{"offset":179,"length":4,"style":"CODE"},{"offset":221,"length":4,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"75eb6","text":" The two major areas where we encounter local variable scoping rules are related to method definiton and method invocation with a block.*","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":84,"style":"ITALIC"},{"offset":101,"length":4,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"fp0bd","text":"Variables and Blocks","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"31f7k","text":"Blocks in Ruby create a new scope for local variables.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d5c8h","text":" Think of the scope created by a block following a method invocation as an inner scope. *Nested blocks will create nested scopes. A variable’s scope is determined by where it is intialized.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":75,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"4lfft","text":"  * Variables initialized in an outer scope can be accessed in an inner scope. Not vice versa.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8ratg","text":"Where a variable is initialized determines its scope","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2lfl8","text":"VARIABLE SHADOWING","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2jrt7","text":"​      n = 10 ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":14,"style":"BOLD"},{"offset":0,"length":14,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"dpjpa","text":"      [1, 2, 3].each do |n| ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":28,"style":"BOLD"},{"offset":0,"length":28,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"bf08b","text":"        puts n ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":15,"style":"BOLD"},{"offset":0,"length":15,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"34lr3","text":"      end","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"esb61","text":"  * Variable shadowing occurs here with the variable n. Access to the outer scope variable is prevented. Avoid doing variable shadowing.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4b78e","text":"Variables and Method Definitions","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9vjsu","text":"Method definition has a scope that is entirely self contained. The only variables a method definition has access to must be passed into the method definition. (Only talking about local variables for now).","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b99hk","text":"Local variables that are not initialized inside a method definition MUST be passed in as parameters","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7nu08","text":"Constants","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"34ir2","text":"Constants are said to have lexical scope, which will have more meaningful consequences when we get to object oriented programming. ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":27,"length":14,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"749al","text":"For now, understand that constants behave differently than from local variables. Constant variables are like global variables. Accessible anywhere.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a0emm","text":"---","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7mdc8","text":"More Variable Scope","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e3ogu","text":"==========================","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cij2s","text":"Method Definition - When defining a Ruby method with the ​def​ keyword.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":17,"style":"BOLD"},{"offset":57,"length":4,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"dpkp1","text":"Method Invocation - When we call a method.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":17,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"e4251","text":"A block is part of a method invocation. In fact, method invocation followed by curly braces or do..end is the way in which define a block in Ruby.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5mea8","text":"The block acts as an argument to the method. In the same way that a local variable can be passed as an argument to a method at invocation, when a method is called with a block it acts as an argument to the method.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2verb","text":"Method and blocks can interact with one another. The level of the interaction is set by the method definition and then used at method invocation. ","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3bcf3","text":"When invoking a method with a block, we aren’t just limited to executing code within the block. The method can return the value of the block to perform some other action.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3tu35","text":"Review some concepts:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bj3os","text":" Method definitions cannot directly access local variables initialized outside of the method definition, nor can local variables initialized outside of the method definition be reassigned from within it. A block can* access local variables initialized outside of the block and can reassign those variables. We already know that methods can access local variables passed in as arguments, and now we have seen that methods can access local variables through interaction with blocks.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":20,"style":"ITALIC"},{"offset":26,"length":186,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"b9vj7","text":"We can think of method definition as setting a scope for any local variables in terms of the paramaters that the method definition has, what it does with those parameters, and how it interacts (if at all) with a block.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"droa9","text":"We can think of the method invocation as using scope set by the method definition. If the method is defined to use a block, then the scope of the block can provide additional flexibility in terms of how the method invocation interacts with its surroundings.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7t9mm","text":"---","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"45n5a","text":"Pass By Reference vs Pass By Value","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"roc8","text":"=========================================","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"53evs","text":"Pass By Value - The method only has a copy of the original object. Operations performed on the object within the method have no effect on the original object outside the method. ","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"epak7","text":"What Ruby Does","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"75t8s","text":"Ruby exhibits a combination of both “pass by reference” as well as “pass by value”. Some people call this pass by reference of the value or call by sharing. The most important thing to remember is: when an operation within the method mutates the caller, it will affect the original object.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":106,"length":50,"style":"ITALIC"},{"offset":198,"length":91,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"37pt0","text":"Variables as pointers","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aqp6b","text":"Variables are pointers to physical space in memory. Variables are essentially labels we refer to some physical memory address in your computer.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cirfs","text":"Different memory spaces can hold the same value, but they are still different places in memory.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"eu01t","text":"Mutating the caller - Mutate the actualy existing address space in memory, thereby affecting all variables that point to that address space.","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":19,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"nn81","text":"---","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fb7sr","text":"Coding Tips 2","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aa00q","text":"====================","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"89ljr","text":"Using new lines to organize code","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1vgar","text":"Should a method return or display?","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cioik","text":"Understand if a method returns a value, or has side effects, or both.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"clgv0","text":"  * “Side effects” is either the method is displaying something to the output or mutates an object","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"262fe","text":"In general, if a method has both side effects and a meaningful value return, it’s a red flag. Try to avoid writing methods like this as it will be very difficult to use these methods in the future.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dai94","text":"Name methods appropriately","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5vkb4","text":"A method should do one thing and be named appropriately. If you can treat a method as a “black box”, then it’s a well designed method.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7saip","text":"Don’t write a method that mutates, outputs, and returns a meaningful value. Make sure your methods just do one thing.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8hmba","text":"Don’t mutate the caller during iteration","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1q1e","text":"Don’t mutate a collection while iterating through it. You can, however, mutate the individual elements within that collection, just not the collection itself. Otherwise, you’ll get unexpected behaviour.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7s0nt","text":"Variable Shadowing","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dpdi9","text":"Occurs when you choose a local variable in an inner scope that shares the same name as an outer scope. Prevents you from accessing the outer scope variable from the inner scope.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ddt60","text":"Don’t use assignment in a conditional","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3brve","text":"Use underscore for unused parameters","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"53j18","text":"Examples:","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5hs56","text":"​names = ['kim', 'joe', 'sam’]","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":30,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"6841c","text":"names.each { |_| puts \"got a name!” }","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":37,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"1r542","text":"names.each_with_index do|_, idx| ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":33,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"3kso8","text":" puts \"#{idx+1}. got a name!” ","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":30,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"acie7","text":"end","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":3,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"5s210","text":"​Gain experience through struggling","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"920jr","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"dateCreated":"2017-09-03T20:12:56.808Z","lastUpdated":"2017-09-03T20:13:49.482Z"}
